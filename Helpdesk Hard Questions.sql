---- Helpdesk Hard Questions 
---- Schema & Tasks Link: https://sqlzoo.net/wiki/Help_Desk




--- 11. Show the manager and number of calls received for each hour of the day on 2017-08-12

-- Step 1: Get shift details for the target date
with shift_details as (
	select 
		s.Shift_date, 
		s.Shift_type, 
		s.Manager, 
		t.Start_time, 
		t.End_time
	from Shift as s 
	inner join Shift_type as t 
		on s.Shift_type = t.Shift_type
	where date(Shift_date) = '2017-08-12'
)

-- Step 2: Count calls per manager by hour
select 
	sd.Manager, 
	DATE_FORMAT(i.call_date, '%Y-%m-%d %H') as Hr, 
	count(*) as cc
from Issue as i 
inner join shift_details as sd
	on time(i.call_date) >= sd.Start_time 
	and time(i.call_date) < sd.End_time
where date(Call_date) = '2017-08-12'
group by 1, 2
order by Hr



	
--- 12. 80/20 rule. It is said that 80% of the calls are generated by 20% of the callers. Is this true? What percentage of calls are generated by the most active 20% of callers.

-- Step 1: Count issues per caller and assign a rank by volume
with call_counts as (
	select 
		Caller_id, 
		count(*) as cc, 
		row_number() over(order by cc desc) as rn
	from Issue
	group by Caller_id
),

-- Step 2: Get total number of issues
total_issues as (
	select count(*) as total_issues
	from Issue
),

-- Step 3: Get total number of callers
total_callers as (
	select count(*) as total_callers 
	from Caller
)

-- Step 4: Calculate the percentage of issues from the top 20% callers
select 
	(sum(cc) * 100.0 / (select total_issues from total_issues)) as t20pc
from call_counts 
where rn <= (
	select floor(total_callers * 0.20)
	from total_callers
)




--- 13. Annoying customers. Customers who call in the last five minutes of a shift are annoying. Find the most active customer who has never been annoying.

-- Step 1: Get shift details for each shift
with Shift_time as (
	select 
		s.Shift_type, 
		timestamp(s.Shift_date, st.Start_time) as Shift_start,
		timestamp(s.Shift_date, st.End_time) as Shift_end
	from Shift as s join Shift_type as st
		on s.Shift_type = st.Shift_type
),

-- Step 2: For each call, map whether it falls in the last 5 minutes of its shift
Mapped as (
	select 
		cu.Company_name,
		case
			when i.Call_date 
				between st.Shift_end - interval 5 minute 
				and st.Shift_end
			then 1
			else 0 
		end as Annoying
	from Customer as cu 
	join Caller as ca 
		on cu.Company_ref = ca.Company_ref
	join Issue as i 
		on ca.Caller_id = i.Caller_id
	join Shift_time as st
		on i.Call_date >= st.Shift_start
		and i.Call_date < st.Shift_end
)

-- Step 3: Return the customer with the largest number of calls who has never called in the last 5 minutes of a shift
select 
	Company_name,
	count(*) as abna
from Mapped
group by Company_name
having Company_name not in (select distinct Company_name from Mapped where Annoying = 1)
order by abna desc
limit 1




--- 14. Maximal usage. If every caller registered with a customer makes at least one call in one day then that customer has "maximal usage" of the service. List the maximal customers for 2017-08-13.

-- Step 1: Get total number of registered callers per client
with Registered_callers as (
	select 
		cu.Company_name,
		cu.Company_ref,
		count(distinct ca.Caller_id) as registered_callers
	from Customer as cu join Caller as ca
		on cu.Company_ref = ca.Company_ref
	group by cu.Company_name, cu.Company_ref)

-- Step 2: For each client, count distinct callers who made a call on 2017-08-13 and return only those clients whose registered-caller count equals their active-caller count 
select 
	rc.Company_name, 
	count(distinct i.Caller_id) as caller_count, 
	rc.registered_callers 
from Issue as i 
	join Caller as ca
		on i.Caller_id = ca.Caller_id
	join Registered_callers as rc
		on rc.Company_ref = ca.Company_ref
where date(i.Call_date) = '2017-08-13'
group by rc.Company_name, rc.registered_callers
having rc.registered_callers = caller_count




--- 15. Consecutive calls occur when an operator deals with two callers within 10 minutes. Find the longest sequence of consecutive calls â€“ give the name of the operator and the first and last call date in the sequence.

-- Step 1: Calculate the gap in minutes to the previous call for each operator 
with Gap_since_prev_call as (
	select 
		Taken_by,
		Call_date,
		timestampdiff(
			minute, 
			lag(timestamp(Call_date)) 
				over(partition by Taken_by order by Call_date asc), 
			timestamp(Call_date)
		) as Gap
	from Issue
),

-- Step 2: Create new sequence flag assuming 10-minute grace 
Sequence_start as (
	select 
		*,
		case 
			when Gap > 10 or Gap is null then 1
			else 0
		end as sequence_start_flag
	from Gap_since_prev_call
),

-- Step 3: Create unique sequence IDs
Sequence_id as (
	select 
		*,
		concat(
			Taken_by, '_', 
			sum(sequence_start_flag) over(partition by Taken_by order by Call_date)
		) as sequence_id
	from Sequence_start
),

-- Step 4: For each call get the first and last call time and total number of the calls in the sequence
Sequence_data as (
	select
		Taken_by,
		min(Call_date) over(
			partition by sequence_id 
			order by Call_date 
			rows between unbounded preceding and unbounded following
		) as first_call,
		max(Call_date) over(
			partition by sequence_id 
			order by Call_date 
			rows between unbounded preceding and unbounded following
		) as last_call,
		count(*) over(
			partition by sequence_id 
			order by Call_date 
			rows between unbounded preceding and unbounded following
		) as calls
	from Sequence_id
)

-- Step 5: Filter the sequence with the highest number of calls
select distinct Taken_by, first_call, last_call, calls
from Sequence_data
order by calls desc
fetch first 1 rows with ties
